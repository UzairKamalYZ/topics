# Customer Care Tool

# Vite 

Vite is a new generation JavaScript build tool that aims to improve the developer experience of Webpack when it comes to building JavaScript applications.

https://blog.bitsrc.io/vite-is-better-than-webpack-d5dd59610d56

# TypeScript
TypeScript will be helpful when we build components for our library, because we will be dealing with props in React components, and defining types will avoid issues when passing props to the components.

# Jest and React Testing Library
Jest is a complete testing framework with a test runner, plus an assertion and mocking library. It also lets the user create snapshot tests for components, which is ideal when building components in React.

React Testing Library helps us write tests as if a real user is working on the elements.

# Styling

In this project, we will not be using regular CSS; instead, we will be using CSS-in-JS. CSS-in-JS provides many benefits over regular CSS, for example:

Reusability: Because CSS-in-JS is written in JavaScript, the styles you define will be reusable JavaScript objects, and you can even extend their properties
Encapsulation: CSS-in-JS scopes are generated by unique selectors that prevent styles from leaking into other components
Dynamic: CSS-in-JS will allow you to dynamically change the properties of the styling depending on the value that the variables hold

https://reactjs.org/docs/hooks-intro.html
https://www.youtube.com/watch?v=dpw9EHDh2bM&t=1s

# Test with selenium

https://medium.com/eoraa-co/end-to-end-testing-of-react-apps-using-selenium-ebc57e4e134a

Or use custom data-attributes in the components:

`
const Button: React.FC<ButtonProps> = ({ text, primary, ...props }) => {
    return (
        <StyledLink
            primary={primary}
            data-selenium-id={text}
            {...props}
        >
            {text}
        </StyledLink>
    );
}
`

# Component state management with hooks

`
import React, { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
`

# Application state persistence management

https://www.npmjs.com/package/little-state-machine

# Rest calls and caching

## Axios - cleaner api to access fetch api

https://axios-http.com/docs/example

## React query - Reduces boilerplate with clean loading and error state

https://codesandbox.io/s/github/tanstack/query/tree/main/examples/react/simple?from-embed=&file=/src/index.jsx

# Mockserver

Mock server powered by Express.js

https://www.npmjs.com/package/express-mock-server

## Pact integration

Consumer-driven contract (CDC) tests are a technique to test integration points between API providers and API consumers without the hassle of end-to-end tests (read it up in a recent blog post). A common use case for consumer-driven contract tests is testing interfaces between services in a microservice architecture.

https://reflectoring.io/pact-node-provider/